After a vite project has been initialized and the example code deleted, these prompts have been executed: 

# setup

set up a canvas in index.html
In main.ts, onload (or immedeately if window is loaded), create a new Loop
instance from loop.ts

loop.ts gets the canvas element as a parameter and initilizes webgl2

main calls loop.start

loop.start registers for resize events, calls internal resize function
initially and then calls internal loop() wich calls itself with
requestAnimFrame

keep the style in the .css file. 

# clearscreen

Can we clear screen with a random color each frame, to see the loop is 
  working?

# sdf raymarching

Now render a fullscreen quad with a simple vertex shader and raymarching in the fragment shader. 

render spheres with SDF and 3D grid domain repetition. 

# fulldome

great. set the canvas aspect ratio to square (fit screen). And then change the view direction calculation, so that the image fullfills domemaster specification. Start rays with distance 1 from the eye to prevent being inside objects. 

# av-controls

I installed av-controls dependency. Can you look at the readme and code in node_modules/av-controls/readme.md|src and then implement the tab receiver? Implement a fader for the sphere size. Introduce the necessary uniforms. 

# camera

Replace the camera movement with a system, where we have targetPos and targetDirection and currentPos and currentDirection
In each frame mix(currentPos, targetPos, 0.01) and mix(currentDirection, targetDirection, 0.01). Normalize currentDirection. 
Add a pad control, when clicked: set targetPos to random [-5,5] ^ 3 and targetDirection to normalized(random [-1,1] ^ 3). 
I added gl-matrix for vector math on the .ts side. 
Initial pos = 0, initial dir = (0,0,-1), initial targets = currents. 
ray start = currentPos. 
for rotation we need 3 vectors: front, up, right. 
up initiall (0, 1, 0), 
right initially (1,0,0)
up and right are calculated after currentDirection is calculated as up = normalize(cross product of front and (previous) right). right = normalize(front, up). 
In the shader add front, up, right multiplied with the respective ray dir components to transform the ray dir. 

# dome simulator
we added dome simulator dependency. let's render to a intermediary texture first and then always use dome-simulator for final rendering. that means creating a fbo and attach a texture. Let's update/create the texture on resize, use canvas resolution. Linear filtering. 
have a look at node_modules/dome-simulator/src to see how to use it. 
then add a switch control (different control namespace called switch) for enabling simulation (bypass argument in simulator.render) - default off. 
bind null fb before calling simulator render.

# adjust full/square screen based on simulation
put the css that makes the canvas square in a css class and toggle along with simulation on off. 
simulation = fullscreen
domemaster = square

